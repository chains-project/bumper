{
    "py/object": "pipeline.types.detected_fault.DetectedFault",
    "identifier": 1661406123,
    "in_class_code": "class FastPolygonizerTests {\n    @Test\n    @Ignore\n    void testRobustnessRandomly() {\n        Random r = new XoRoShiRo128PlusRandom(0);\n        for (int k = 0; k < 100; k++) {\n            List<SegmentString> segmentStrings = new ArrayList<>(111 + k);\n            for (int i = 0; i < (111 + k); i++) {\n                segmentStrings.add(new NodedSegmentString(new Coordinate[]{ new Coordinate(r.nextDouble() * 10000, r.nextDouble() * 10000), new Coordinate(r.nextDouble() * 10000, r.nextDouble() * 13337) }, null));\n            }\n            Collection<SegmentString> nodedSS = PGS.nodeSegmentStrings(segmentStrings);\n            Collection<PEdge> nodedEdges = new ArrayList<>();\n            nodedSS.forEach(ss -> nodedEdges.add(new PEdge(PGS.toPVector(ss.getCoordinate(0)), PGS.toPVector(ss.getCoordinate(1)))));\n            Collection<PEdge> nodedEdgesSet = new HashSet<>(nodedEdges);\n            final Polygonizer polygonizerJTS = new Polygonizer();\n            polygonizerJTS.setCheckRingsValid(false);\n            nodedEdgesSet.forEach(e -> {\n                final LineString l = PGS.GEOM_FACTORY.createLineString(new Coordinate[]{ PGS.coordFromPVector(e.a), PGS.coordFromPVector(e.b) });\n                polygonizerJTS.add(l);\n            });\n            long t1 = System.currentTimeMillis();\n            @SuppressWarnings(\"unchecked\")\n            Collection<Polygon> JTS = polygonizerJTS.getPolygons();\n            long t2 = System.currentTimeMillis();\n            long timeJTS = t2 - t1;\n            t1 = System.currentTimeMillis();\n            PShape FP = polygonize(nodedEdgesSet);\n            t2 = System.currentTimeMillis();\n            long timeFP = t2 - t1;\n            // System.out.println(timeJTS + \" \" + timeFP + \" \" + JTS.size());\n            assertEquals(JTS.size(), FP.getChildCount());\n        }\n    }\n}",
    "qualified_in_class_code": "class FastPolygonizerTests {\n    @org.junit.jupiter.api.Test\n    @micycle.pgs.Ignore\n    void testRobustnessRandomly() {\n        java.util.Random r = new it.unimi.dsi.util.XoRoShiRo128PlusRandom(0);\n        for (int k = 0; k < 100; k++) {\n            java.util.List<org.locationtech.jts.noding.SegmentString> segmentStrings = new java.util.ArrayList<>(111 + k);\n            for (int i = 0; i < (111 + k); i++) {\n                segmentStrings.add(new org.locationtech.jts.noding.NodedSegmentString(new org.locationtech.jts.geom.Coordinate[]{ new org.locationtech.jts.geom.Coordinate(r.nextDouble() * 10000, r.nextDouble() * 10000), new org.locationtech.jts.geom.Coordinate(r.nextDouble() * 10000, r.nextDouble() * 13337) }, null));\n            }\n            java.util.Collection<org.locationtech.jts.noding.SegmentString> nodedSS = PGS.nodeSegmentStrings(segmentStrings);\n            java.util.Collection<micycle.pgs.commons.PEdge> nodedEdges = new java.util.ArrayList<>();\n            nodedSS.forEach(( ss) -> nodedEdges.add(new micycle.pgs.commons.PEdge(PGS.toPVector(ss.getCoordinate(0)), PGS.toPVector(ss.getCoordinate(1)))));\n            java.util.Collection<micycle.pgs.commons.PEdge> nodedEdgesSet = new java.util.HashSet<>(nodedEdges);\n            final org.locationtech.jts.operation.polygonize.Polygonizer polygonizerJTS = new org.locationtech.jts.operation.polygonize.Polygonizer();\n            polygonizerJTS.setCheckRingsValid(false);\n            nodedEdgesSet.forEach(( e) -> {\n                final org.locationtech.jts.geom.LineString l = PGS.GEOM_FACTORY.createLineString(new org.locationtech.jts.geom.Coordinate[]{ PGS.coordFromPVector(e.a), PGS.coordFromPVector(e.b) });\n                polygonizerJTS.add(l);\n            });\n            long t1 = java.lang.System.currentTimeMillis();\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Collection<org.locationtech.jts.geom.Polygon> JTS = polygonizerJTS.getPolygons();\n            long t2 = java.lang.System.currentTimeMillis();\n            long timeJTS = t2 - t1;\n            t1 = java.lang.System.currentTimeMillis();\n            processing.core.PShape FP = FastPolygonizer.polygonize(nodedEdgesSet);\n            t2 = java.lang.System.currentTimeMillis();\n            long timeFP = t2 - t1;\n            // System.out.println(timeJTS + \" \" + timeFP + \" \" + JTS.size());\n            assertEquals(JTS.size(), FP.getChildCount());\n        }\n    }\n}",
    "plausible_dependency_identifier": null,
    "error_info": {
        "py/object": "pipeline.types.error_info.ErrorInfo",
        "additional_info": "  symbol:   class Ignore\n  location: class micycle.pgs.FastPolygonizerTests\n",
        "error_message": "[ERROR] /PGS/src/test/java/micycle/pgs/FastPolygonizerTests.java:[102,10] cannot find symbol",
        "client_file_path": "/PGS/src/test/java/micycle/pgs/FastPolygonizerTests.java",
        "client_line_position": "102"
    },
    "client_end_line_number": 137,
    "client_line_number": 101,
    "method_code": "@Test\n\t@Ignore\n\tvoid testRobustnessRandomly() {\n\t\tRandom r = new XoRoShiRo128PlusRandom(0);\n\t\tfor (int k = 0; k < 100; k++) {\n\t\t\tList<SegmentString> segmentStrings = new ArrayList<>(111 + k);\n\t\t\tfor (int i = 0; i < 111 + k; i++) {\n\t\t\t\tsegmentStrings.add(new NodedSegmentString(new Coordinate[] { new Coordinate(r.nextDouble() * 10000, r.nextDouble() * 10000),\n\t\t\t\t\t\tnew Coordinate(r.nextDouble() * 10000, r.nextDouble() * 13337) }, null));\n\t\t\t}\n\t\t\tCollection<SegmentString> nodedSS = PGS.nodeSegmentStrings(segmentStrings);\n\t\t\tCollection<PEdge> nodedEdges = new ArrayList<>();\n\t\t\tnodedSS.forEach(ss -> nodedEdges.add(new PEdge(PGS.toPVector(ss.getCoordinate(0)), PGS.toPVector(ss.getCoordinate(1)))));\n\t\t\tCollection<PEdge> nodedEdgesSet = new HashSet<>(nodedEdges);\n\n\t\t\tfinal Polygonizer polygonizerJTS = new Polygonizer();\n\t\t\tpolygonizerJTS.setCheckRingsValid(false);\n\t\t\tnodedEdgesSet.forEach(e -> {\n\t\t\t\tfinal LineString l = PGS.GEOM_FACTORY\n\t\t\t\t\t\t.createLineString(new Coordinate[] { PGS.coordFromPVector(e.a), PGS.coordFromPVector(e.b) });\n\t\t\t\tpolygonizerJTS.add(l);\n\t\t\t});\n\n\t\t\tlong t1 = System.currentTimeMillis();\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tCollection<Polygon> JTS = polygonizerJTS.getPolygons();\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tlong timeJTS = t2 - t1;\n\n\t\t\tt1 = System.currentTimeMillis();\n\t\t\tPShape FP = polygonize(nodedEdgesSet);\n\t\t\tt2 = System.currentTimeMillis();\n\t\t\tlong timeFP = t2 - t1;\n//\t\t\tSystem.out.println(timeJTS + \" \" + timeFP + \" \" + JTS.size());\n\t\t\tassertEquals(JTS.size(), FP.getChildCount());\n\t\t}\n\t}",
    "qualified_code": "@org.junit.jupiter.api.Test\n@micycle.pgs.Ignore\nvoid testRobustnessRandomly() {\n    java.util.Random r = new it.unimi.dsi.util.XoRoShiRo128PlusRandom(0);\n    for (int k = 0; k < 100; k++) {\n        java.util.List<org.locationtech.jts.noding.SegmentString> segmentStrings = new java.util.ArrayList<>(111 + k);\n        for (int i = 0; i < (111 + k); i++) {\n            segmentStrings.add(new org.locationtech.jts.noding.NodedSegmentString(new org.locationtech.jts.geom.Coordinate[]{ new org.locationtech.jts.geom.Coordinate(r.nextDouble() * 10000, r.nextDouble() * 10000), new org.locationtech.jts.geom.Coordinate(r.nextDouble() * 10000, r.nextDouble() * 13337) }, null));\n        }\n        java.util.Collection<org.locationtech.jts.noding.SegmentString> nodedSS = PGS.nodeSegmentStrings(segmentStrings);\n        java.util.Collection<micycle.pgs.commons.PEdge> nodedEdges = new java.util.ArrayList<>();\n        nodedSS.forEach(( ss) -> nodedEdges.add(new micycle.pgs.commons.PEdge(PGS.toPVector(ss.getCoordinate(0)), PGS.toPVector(ss.getCoordinate(1)))));\n        java.util.Collection<micycle.pgs.commons.PEdge> nodedEdgesSet = new java.util.HashSet<>(nodedEdges);\n        final org.locationtech.jts.operation.polygonize.Polygonizer polygonizerJTS = new org.locationtech.jts.operation.polygonize.Polygonizer();\n        polygonizerJTS.setCheckRingsValid(false);\n        nodedEdgesSet.forEach(( e) -> {\n            final org.locationtech.jts.geom.LineString l = PGS.GEOM_FACTORY.createLineString(new org.locationtech.jts.geom.Coordinate[]{ PGS.coordFromPVector(e.a), PGS.coordFromPVector(e.b) });\n            polygonizerJTS.add(l);\n        });\n        long t1 = java.lang.System.currentTimeMillis();\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Collection<org.locationtech.jts.geom.Polygon> JTS = polygonizerJTS.getPolygons();\n        long t2 = java.lang.System.currentTimeMillis();\n        long timeJTS = t2 - t1;\n        t1 = java.lang.System.currentTimeMillis();\n        processing.core.PShape FP = FastPolygonizer.polygonize(nodedEdgesSet);\n        t2 = java.lang.System.currentTimeMillis();\n        long timeFP = t2 - t1;\n        // System.out.println(timeJTS + \" \" + timeFP + \" \" + JTS.size());\n        assertEquals(JTS.size(), FP.getChildCount());\n    }\n}",
    "method_name": "testRobustnessRandomly"
}