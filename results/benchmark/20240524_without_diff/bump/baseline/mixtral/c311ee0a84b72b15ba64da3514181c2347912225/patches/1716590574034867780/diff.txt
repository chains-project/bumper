0a1,27
> import static org.hamcrest.MatcherAssert.assertThat;
> import static org.hamcrest.Matchers.instanceOf;
> import static org.hamcrest.Matchers.notNullValue;
> import static org.hamcrest.Matchers.stringContainsInOrder;
> import java.nio.charset.StandardCharsets;
> import java.util.concurrent.CompletableFuture;
> import org.junit.jupiter.api.Test;
> import com.artipie.asto.CheckedBlobSource;
> import com.artipie.asto.Content;
> import com.artipie.asto.Digest;
> import com.artipie.asto.Extend;
> import com.artipie.asto.Memory;
> import com.artipie.asto.Storage;
> import com.artipie.asto.layer.Layout;
> import com.artipie.asto.repo.RepoName;
> import com.artipie.asto.test.TestResource;
> import com.google.common.base.Throwables;
> import org.junit.jupiter.api.extension.ExtendWith;
> import org.mockito.Mockito;
> import io.vertx.core.Future;
> import io.vertx.ext.unit.Async;
> import io.vertx.ext.unit.TestContext;
> import io.vertx.ext.unit.junit.VertxExtension;
> 
> @ExtendWith(VertxExtension.class)
> class AstoBlobsITCase {
> 
2,6c29,34
<     void failsOnDigestMismatch() {
<         final InMemoryStorage storage = new InMemoryStorage();
<         final AstoBlobs blobs = new AstoBlobs(
<             storage, new DefaultLayout(), new RepoName.Simple("any")
<         );
---
>     void failsOnDigestMismatch(TestContext ctx) {
>         final Async async = ctx.async();
>         final Storage storage = Memory.buffer();
>         final Layout layout = Mockito.mock(Layout.class);
>         final RepoName repoName = new RepoName.Simple("any");
>         final AstoBlobs blobs = new AstoBlobs(storage, layout, repoName);
8,33c36,39
<         blobs.put(
<             new CheckedBlobSource(new Content.From("data".getBytes()), new Digest.Sha256(digest))
<         ).toCompletableFuture().handle(
<             (blob, throwable) -> {
<                 MatcherAssert.assertThat(
<                     "Exception thrown",
<                     throwable,
<                     new IsNot<>(new IsNull<>())
<                 );
<                 MatcherAssert.assertThat(
<                     "Exception is InvalidDigestException",
<                     Throwables.getRootCause(throwable),
<                     new IsInstanceOf(InvalidDigestException.class)
<                 );
<                 MatcherAssert.assertThat(
<                     "Exception message contains calculated digest",
<                     Throwables.getRootCause(throwable).getMessage(),
<                     new StringContains(
<                         true,
<                         "3a6eb0790f39ac87c94f3856b2dd2c5d110e6811602261a9a923d3bb23adc8b7"
<                     )
<                 );
<                 MatcherAssert.assertThat(
<                     "Exception message contains expected digest",
<                     Throwables.getRootCause(throwable).getMessage(),
<                     new StringContains(true, digest)
---
>         final Content content = Content.from(TestResource.classpath("data"), StandardCharsets.UTF_8);
>         final Digest calculatedDigest = Digest.Sha256. Blake2b_256.sha256(content.asInputStream());
>         final CheckedBlobSource checkedBlobSource = new CheckedBlobSource(
>             content, calculatedDigest
35c41,52
<                 return CompletableFuture.allOf();
---
>         blobs.put(checkedBlobSource)
>             .onSuccess(blob -> ctx.fail("Exception expected"))
>             .onFailure(throwable -> {
>                 assertThat(throwable, notNullValue());
>                 assertThat(throwable, instanceOf(InvalidDigestException.class));
>                 final String message = throwable.getMessage();
>                 assertThat(message, stringContainsInOrder(
>                     calculatedDigest.encoded(),
>                     digest
>                 ));
>                 async.complete();
>             });
37d53
<         ).join();
