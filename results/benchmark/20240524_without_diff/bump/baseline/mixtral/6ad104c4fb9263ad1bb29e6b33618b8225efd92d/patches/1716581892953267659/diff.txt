1c1,38
< import org.bouncycastle.crypto.tls.AlertDescription;
\ No newline at end of file
---
> import org.bouncycastle.tls.AlertDescription;
> import org.bouncycastle.tls.TlsContext;
> import org.bouncycastle.tls.crypto.TlsCipher;
> import org.bouncycastle.util.Arrays;
> 
> import java.io.IOException;
> import java.security.SecureRandom;
> 
> public class ChachaDecoder {
> 
>     private static final int CHACHA20_POLY1305_TAG_LENGTH = 16;
> 
>     private final TlsContext tlsContext;
>     private final TlsCipher cipher;
>     private final SecureRandom random;
>     private final byte[] scratch = new byte[16];
> 
>     public ChachaDecoder(TlsContext tlsContext) {
>         this.tlsContext = tlsContext;
>         this.cipher = tlsContext.getCipherSuite().createCipher(tlsContext);
>         this.random = new SecureRandom();
>     }
> 
>     public byte[] decode(byte[] encrypted, int offset, int length) throws IOException {
>         byte[] decrypted = new byte[length - CHACHA20_POLY1305_TAG_LENGTH];
>         cipher.decodeCiphertext(scratch, encrypted, offset, length, decrypted, 0);
>         if (!Arrays.constantTimeAreEqual(scratch, Arrays.subarray(encrypted, offset + length - CHACHA20_POLY1305_TAG_LENGTH, offset + length))) {
>             throw new IOException("Invalid MAC");
>         }
>         return decrypted;
>     }
> 
>     public void encode(byte[] plaintext, int offset, int length, byte[] encrypted) throws IOException {
>         byte[] mac = new byte[CHACHA20_POLY1305_TAG_LENGTH];
>         cipher.encrypt(plaintext, offset, length, mac, scratch);
>         System.arraycopy(mac, 0, encrypted, offset + length, mac.length);
>     }
> }
\ No newline at end of file
