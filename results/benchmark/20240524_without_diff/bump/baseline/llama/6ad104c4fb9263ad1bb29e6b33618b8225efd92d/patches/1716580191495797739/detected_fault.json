{
    "py/object": "pipeline.types.detected_fault.DetectedFault",
    "identifier": 53871235,
    "in_class_code": "class ConnectionImpl implements HomekitClientConnection {\n    private final HttpSession httpSession;\n\n    private LengthPrefixedByteArrayProcessor binaryProcessor;\n\n    private int inboundBinaryMessageCount = 0;\n\n    private int outboundBinaryMessageCount = 0;\n\n    private byte[] readKey;\n\n    private byte[] writeKey;\n\n    private boolean isUpgraded = false;\n\n    private final Consumer<HttpResponse> outOfBandMessageCallback;\n\n    private final SubscriptionManager subscriptions;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitClientConnection.class);\n\n    public ConnectionImpl(HomekitAuthInfo authInfo, HomekitRegistry registry, Consumer<HttpResponse> outOfBandMessageCallback, SubscriptionManager subscriptions, JmdnsHomekitAdvertiser advertiser) {\n        httpSession = new HttpSession(authInfo, registry, subscriptions, this, advertiser);\n        this.outOfBandMessageCallback = outOfBandMessageCallback;\n        this.subscriptions = subscriptions;\n    }\n\n    private byte[] decrypt(byte[] msg) {\n        byte[] mac = new byte[16];\n        byte[] ciphertext = new byte[msg.length - 16];\n        System.arraycopy(msg, 0, ciphertext, 0, msg.length - 16);\n        System.arraycopy(msg, msg.length - 16, mac, 0, 16);\n        byte[] additionalData = ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(((short) (msg.length - 16))).array();\n        try {\n            byte[] nonce = Pack.longToLittleEndian(inboundBinaryMessageCount++);\n            return new ChachaDecoder(readKey, nonce).decodeCiphertext(mac, additionalData, ciphertext);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}",
    "qualified_in_class_code": "class ConnectionImpl implements io.github.hapjava.server.impl.http.HomekitClientConnection {\n    private final io.github.hapjava.server.impl.connections.HttpSession httpSession;\n\n    private io.github.hapjava.server.impl.connections.LengthPrefixedByteArrayProcessor binaryProcessor;\n\n    private int inboundBinaryMessageCount = 0;\n\n    private int outboundBinaryMessageCount = 0;\n\n    private byte[] readKey;\n\n    private byte[] writeKey;\n\n    private boolean isUpgraded = false;\n\n    private final java.util.function.Consumer<io.github.hapjava.server.impl.http.HttpResponse> outOfBandMessageCallback;\n\n    private final io.github.hapjava.server.impl.connections.SubscriptionManager subscriptions;\n\n    private static final org.slf4j.Logger LOGGER = org.slf4j.LoggerFactory.getLogger(io.github.hapjava.server.impl.http.HomekitClientConnection.class);\n\n    public ConnectionImpl(io.github.hapjava.server.HomekitAuthInfo authInfo, io.github.hapjava.server.impl.HomekitRegistry registry, java.util.function.Consumer<io.github.hapjava.server.impl.http.HttpResponse> outOfBandMessageCallback, io.github.hapjava.server.impl.connections.SubscriptionManager subscriptions, io.github.hapjava.server.impl.jmdns.JmdnsHomekitAdvertiser advertiser) {\n        httpSession = new io.github.hapjava.server.impl.connections.HttpSession(authInfo, registry, subscriptions, this, advertiser);\n        this.outOfBandMessageCallback = outOfBandMessageCallback;\n        this.subscriptions = subscriptions;\n    }\n\n    private byte[] decrypt(byte[] msg) {\n        byte[] mac = new byte[16];\n        byte[] ciphertext = new byte[msg.length - 16];\n        java.lang.System.arraycopy(msg, 0, ciphertext, 0, msg.length - 16);\n        java.lang.System.arraycopy(msg, msg.length - 16, mac, 0, 16);\n        byte[] additionalData = java.nio.ByteBuffer.allocate(2).order(java.nio.ByteOrder.LITTLE_ENDIAN).putShort(((short) (msg.length - 16))).array();\n        try {\n            byte[] nonce = org.bouncycastle.util.Pack.longToLittleEndian(inboundBinaryMessageCount++);\n            return new io.github.hapjava.server.impl.crypto.ChachaDecoder(readKey, nonce).decodeCiphertext(mac, additionalData, ciphertext);\n        } catch (java.io.IOException e) {\n            throw new java.lang.RuntimeException(e);\n        }\n    }\n}",
    "plausible_dependency_identifier": null,
    "error_info": {
        "py/object": "pipeline.types.error_info.ErrorInfo",
        "additional_info": "  required: byte[],byte[]\n  found: byte[],byte[],byte[]\n  reason: actual and formal argument lists differ in length\n",
        "error_message": "[ERROR] /HAP-Java/src/main/java/io/github/hapjava/server/impl/connections/ConnectionImpl.java:[133,47] method decodeCiphertext in class io.github.hapjava.server.impl.crypto.ChachaDecoder cannot be applied to given types;",
        "client_file_path": "/HAP-Java/src/main/java/io/github/hapjava/server/impl/connections/ConnectionImpl.java",
        "client_line_position": "133"
    },
    "client_end_line_number": 137,
    "client_line_number": 121,
    "method_code": "private byte[] decrypt(byte[] msg) {\n    byte[] mac = new byte[16];\n    byte[] ciphertext = new byte[msg.length - 16];\n    System.arraycopy(msg, 0, ciphertext, 0, msg.length - 16);\n    System.arraycopy(msg, msg.length - 16, mac, 0, 16);\n    byte[] additionalData =\n        ByteBuffer.allocate(2)\n            .order(ByteOrder.LITTLE_ENDIAN)\n            .putShort((short) (msg.length - 16))\n            .array();\n    try {\n      byte[] nonce = Pack.longToLittleEndian(inboundBinaryMessageCount++);\n      return new ChachaDecoder(readKey, nonce).decodeCiphertext(mac, additionalData, ciphertext);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }",
    "qualified_code": "private byte[] decrypt(byte[] msg) {\n    byte[] mac = new byte[16];\n    byte[] ciphertext = new byte[msg.length - 16];\n    java.lang.System.arraycopy(msg, 0, ciphertext, 0, msg.length - 16);\n    java.lang.System.arraycopy(msg, msg.length - 16, mac, 0, 16);\n    byte[] additionalData = java.nio.ByteBuffer.allocate(2).order(java.nio.ByteOrder.LITTLE_ENDIAN).putShort(((short) (msg.length - 16))).array();\n    try {\n        byte[] nonce = org.bouncycastle.util.Pack.longToLittleEndian(inboundBinaryMessageCount++);\n        return new io.github.hapjava.server.impl.crypto.ChachaDecoder(readKey, nonce).decodeCiphertext(mac, additionalData, ciphertext);\n    } catch (java.io.IOException e) {\n        throw new java.lang.RuntimeException(e);\n    }\n}",
    "method_name": "decrypt"
}