import org.bouncycastle.crypto.tls.TlsFatalAlert;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.ByteBuffer;
import java.security.GeneralSecurityException;
import java.util.Arrays;

public byte[] decode(byte[] encrypted, byte[] key, byte[] iv) throws GeneralSecurityException {
    SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
    IvParameterSpec ivSpec = new IvParameterSpec(iv);

    Cipher cipher = Cipher.getInstance("AES/CTR/NoPadding");
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

    byte[] decrypted = cipher.doFinal(encrypted);

    // Remove the initial 4 bytes (nonce)
    byte[] decryptedWithoutNonce = Arrays.copyOfRange(decrypted, 4, decrypted.length);

    // Process the remaining bytes as before
    ByteBuffer decryptedBuffer = ByteBuffer.wrap(decryptedWithoutNonce);
    short tag = decryptedBuffer.getShort();
    if (tag != 0x4944) {
        throw new TlsFatalAlert(TlsFatalAlert.DECODE_ERROR, "Invalid tag");
    }

    int length = decryptedBuffer.getInt();
    if (length > decryptedWithoutNonce.length - 4) {
        throw new TlsFatalAlert(TlsFatalAlert.DECODE_ERROR, "Invalid length");
    }

    byte[] decoded = new byte[length];
    decryptedBuffer.get(decoded);

    return decoded;
}