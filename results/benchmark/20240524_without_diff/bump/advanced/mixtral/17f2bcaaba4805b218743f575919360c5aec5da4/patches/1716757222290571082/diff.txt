1,6c1
< @Test
<         void testAreaMerge() {
<                 PShape mesh = PGS_Triangulation.delaunayTriangulation(PGS_PointSet.random(0, 0, 1000, 1000, 1111, 0));
<                 List<PShape> faces = PGS_Conversion.getChildren(mesh);
<                 faces.sort((a, b) -> Double.compare(PGS_ShapePredicates.area(a), PGS_ShapePredicates.area(b)));
<                 double areaThreshold = PGS_ShapePredicates.area(faces.get(faces.size() / 2));
---
> import static org.junit.jupiter.api.Assertions.assertTrue;
8,9c3,10
<                 PShape mergedMesh = PGS_Meshing.areaMerge(mesh, areaThreshold);
<                 assertTrue(PGS_Conversion.getChildren(mergedMesh).stream().allMatch(f -> PGS_ShapePredicates.area(f) >= areaThreshold));
---
> @org.junit.jupiter.api.Test
> void testAreaMerge() {
>     processing.core.PShape mesh = micycle.pgs.PGS_Triangulation.delaunayTriangulation(micycle.pgs.PGS_PointSet.random(0, 0, 1000, 1000, 1111, 0));
>     java.util.List<processing.core.PShape> faces = micycle.pgs.PGS_Conversion.getChildren(mesh);
>     faces.sort(( a, b) -> java.lang.Double.compare(micycle.pgs.PGS_ShapePredicates.area(a), micycle.pgs.PGS_ShapePredicates.area(b)));
>     double areaThreshold = micycle.pgs.PGS_ShapePredicates.area(faces.get(faces.size() / 2));
>     processing.core.PShape mergedMesh = micycle.pgs.PGS_Meshing.areaMerge(mesh, areaThreshold);
>     assertTrue(micycle.pgs.PGS_Conversion.getChildren(mergedMesh).stream().allMatch(( f) -> micycle.pgs.PGS_ShapePredicates.area(f) >= areaThreshold));
11c12
<                 assertEquals(PGS_ShapePredicates.area(mesh), PGS_ShapePredicates.area(mergedMesh), 1e-6);
---
>     assertTrue(Math.abs(micycle.pgs.PGS_ShapePredicates.area(mesh) - micycle.pgs.PGS_ShapePredicates.area(mergedMesh)) < 1.0E-6);
