import org.bouncycastle.util.Arrays;

public class ChachaDecoder {
    private static final int CHACHA_IV_SIZE = 8;
    private static final int CHACHA_KEY_SIZE = 32;
    private static final int CHACHA_BLOCK_SIZE = 64;
    private static final int CHACHA_STATE_SIZE = 64;

    private byte[] key;
    private byte[] iv;

    public ChachaDecoder(byte[] key, byte[] iv) {
        this.key = key;
        this.iv = iv;
    }

    public void decrypt(byte[] ciphertext, int offset, int len) {
        byte[] plaintext = new byte[len];
        Arrays.fill(plaintext, (byte) 0);
        int decryptedLen = len - CHACHA_IV_SIZE;
        int remaining = len % CHACHA_BLOCK_SIZE;
        int blocks = (len - 1) / CHACHA_BLOCK_SIZE + 1;
        int offsetInBlock = offset % CHACHA_BLOCK_SIZE;
        int blockIndex = offset / CHACHA_BLOCK_SIZE;
        byte[] block = new byte[CHACHA_BLOCK_SIZE];

        for (int i = 0; i < blocks; i++) {
            int blockOffset = i * CHACHA_BLOCK_SIZE;
            System.arraycopy(ciphertext, blockOffset, block, 0, CHACHA_BLOCK_SIZE);
            Chacha.decrypt(block, key, iv, block);
            System.arraycopy(block, 0, plaintext, blockOffset, CHACHA_BLOCK_SIZE);
        }

        if (remaining > 0) {
            int remainingBlocks = (remaining - 1) / CHACHA_BLOCK_SIZE + 1;
            int remainingOffset = remaining % CHACHA_BLOCK_SIZE;
            byte[] remainingBlock = new byte[remaining];
            System.arraycopy(ciphertext, len - remaining, remainingBlock, 0, remaining);
            Chacha.decrypt(remainingBlock, key, iv, remainingBlock);
            System.arraycopy(remainingBlock, 0, plaintext, len - remaining, remaining);
        }

        return plaintext;
    }
}