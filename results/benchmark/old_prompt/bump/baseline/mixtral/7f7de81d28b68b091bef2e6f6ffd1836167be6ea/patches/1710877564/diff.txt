1,7d0
< /**
<      * Sets the private registry value of {@link DefaultMOServer} via reflection.
<      * FIXME
<      * If there is any possibility to avoid this, then replace!
<      *
<      * @param group {@link ManagedObject} to register.
<      */
10,12c3,19
<             final Field registry = server.getClass().getDeclaredField("registry");
<             registry.setAccessible(true);
<             final SortedMap<MOScope, ManagedObject> reg = server.getRegistry();
---
>         Class<?> registryClass = server.getClass();
>         Field registryField = registryClass.getDeclaredField("registry");
>         registryField.setAccessible(true);
>         Object registry = registryField.get(server);
> 
>         Class<? extends SortedMap> regClass = registry.getClass();
>         Type genericType = regClass.getGenericInterfaces()[0];
>         if (!(genericType instanceof ParameterizedType)) {
>             throw new RuntimeException("Unexpected registry type: " + regClass.getName());
>         }
> 
>         ParameterizedType pType = (ParameterizedType) genericType;
>         Class<?> managedObjectType = (Class) pType.getActualTypeArguments()[1];
> 
>         Method getRegistryMethod = registryClass.getMethod("getRegistry");
>         SortedMap<MOScope, ManagedObject> reg = (SortedMap<MOScope, ManagedObject>) getRegistryMethod.invoke(server);
> 
14,16c21,23
<             reg.put(contextScope, group);
<             registry.set(server, reg);
<         } catch (NoSuchFieldException | IllegalAccessException e) {
---
>         reg.put(contextScope, (ManagedObject) group.newInstance(managedObjectType));
>         registryField.set(server, reg);
>     } catch (ReflectiveOperationException | InstantiationException e) {
